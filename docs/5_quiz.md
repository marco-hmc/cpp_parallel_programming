
#### 生产者消费者消息队列 线程

- - **一/多机数据处理**.

  有 10 台机器,每台机器上保存着 10 亿个 64-bit 整数(不一定刚好 10 亿个,可能有上下几千万的浮动),一共约 100 亿个整数(其实一共也就 80GB 数据,不算大,选这个量级是考虑了 VPS 虚拟机的容量,便于实验).编程求出:

  \1. 这些数的平均数.

  \2. 这些数的中位数.

  \3. 出现次数最多的 100 万个数.

  \*4. (附加题)对这 100 亿个整数排序,结果顺序存放到这 10 台机器上.

  \*5. (附加健壮性要求)你的程序应该能正确应对输入数据的各种分布(均匀/正态/Zipf).

  \*6. (附加伸缩性要求)你的程序应该能平滑扩展到更多的机器,支持更大的数据量.比如 20 台机器/一共 200 亿个整数,或者 50 台机器/一共 500 亿个整数.

- **二/N-皇后问题的多机并行求解**.利用多台机器求出 N-皇后问题有多少个解.(注意目前的世界纪录是 N = 26,[A000170 - OEIS](https://link.zhihu.com/?target=http%3A//oeis.org/A000170) )

  \1. 8 皇后问题在单机上的运算时间是毫秒级,有 92 个解,编程实现之.

  \2. 研究 N-皇后问题的并行算法,写一个单机多线程程序,争取达到线性加速比(以 CPU 核数计).再设法将算法扩展到多机并行.

  \3. 用 10 台 8 核的机器(一共 80 个 CPU cores),求解 19-皇后和 20-皇后问题,看看分别需要多少运行时间.你的方案能否平滑扩展到更多的机器?

  \*4. (附加题)如果这 10 台机器的型号不一,有 8 核也有 16 核,有旧 CPU 也有更快的新 CPU,你该采用何种负载均衡策略,以求缩短求解问题的时间(至少比 plain round-robin 算法要好)?

如果是单核，多线程编程是不会出现数据竞争的情况吗？

#### 内存屏障

```c++
  x = x + 1
  y = x * 2
  z = x * y
```

由于编译器优化的原因，变量 x 的值可能会一直停留在寄存器中，编译器可能会在执行了多行代码后才生成一条写内存的指令，将 x 的值写入内存。

那么假设有一个全局变量 x，在不显示指明内存屏障的情况下:

```c++
  lock();
  x = x + 1
  unlock();
```

1. **线程安全性**：

   - 在多线程编程中，锁的主要作用是确保临界区代码的互斥执行。然而，锁并不一定会强制编译器在 unlock 之前将所有寄存器中的值写回内存。
   - 如果 x 的值在 unlock 之后才写入内存，其他线程在获取锁后可能会看到旧的 x 值，从而导致线程不安全。

2. **编译器优化**：
   - 编译器通常不会隐式地加入内存屏障，除非它明确知道某个函数（如 unlock）需要内存屏障。
   - 编译器无法识别用户自定义的 unlock 函数，因此不会自动加入内存屏障。
   - 如果在自定义的 unlock 函数，是简单的调用系统 unlock 方式的，一般也不需要担心，也会有内存屏障保证。


